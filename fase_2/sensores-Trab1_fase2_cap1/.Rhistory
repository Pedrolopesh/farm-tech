qqPlot(modelo_simples, main = "Modelo Simples")
qqPlot(modelo_simples, main = "Modelo Simples")
qqPlot(modelo_multiplo, main = "Modelo Multiplo")
qqPlot(modelo_simples, main = "Modelo Simples")
qqPlot(modelo_multiplo, main = "Modelo Multiplo")
qqPlot(modelo_simples, main = "Modelo Simples")
# Instalar e carregar pacotes necessários
install.packages(c( "ggplot2", "modeest", "scales","readxl","dplyr","writexl"))
# Dados de vendas mensais
vendas <- c(120, 150, 130, 170, 200, 180, 160, 190)
# Calculando a média
media_vendas <- mean(vendas)  # Mostra a média das vendas
print(paste("Média de vendas:", media_vendas))
# Calculando a mediana
# A mediana é uma medida estatística que representa o valor central de um conjunto de dados quando esses dados estão organizados em ordem crescente ou decrescente.
mediana_vendas <- median(vendas)
"Mediana de vendas: 165"
# Calculando o desvio padrão
# O desvio padrão indica a medida de dispersão de um conjunto de dados em relação à sua média aritmética,
# indicando o quão próximas ou distantes dela esses dados estão.
desvio_padrao_vendas <- sd(vendas)
print(paste("Desvio padrão das vendas:", desvio_padrao_vendas))  # Mostra o desvio padrão das vendas
# ----------------------------
# Exemplo: Vendas mensais
# ----------------------------
vendas <- c(120, 150, 130, 170, 200, 180, 160, 190)
# Calcula média e desvio padrão
media <- mean(vendas)
desvio_padrao <- sd(vendas)
# Exibe os resultados
cat("Média das vendas:", media, "\n")
cat("Desvio padrão das vendas:", desvio_padrao, "\n")
library(ggplot2)
# Cria um data frame para o gráfico
dados <- data.frame(vendas = vendas)
ggplot(dados, aes(x = vendas)) +
geom_histogram(binwidth = 10, fill = "skyblue", color = "black") +
geom_vline(aes(xintercept = media), color = "red", linetype = "dashed", size = 1.2) +
geom_vline(aes(xintercept = media + desvio_padrao), color = "darkgreen", linetype = "dotted", size = 1) +
geom_vline(aes(xintercept = media - desvio_padrao), color = "darkgreen", linetype = "dotted", size = 1) +
labs(
title = "Distribuição das Vendas Mensais",
subtitle = paste0("Média = ", round(media,1),
" | Desvio Padrão = ", round(desvio_padrao,1)),
x = "Vendas Mensais",
y = "Frequência"
) +
theme_minimal()
# Dados para análise
tempos_antes <- c(220, 210, 215, 210, 225, 220, 230, 215)
# Realizando o teste de hipóteses
# O T.TEST comumente usados para comparar as médias de dois grupos e determinar se há uma diferença estatisticamente significativa entre eles.
teste_hipotese <- t.test(tempos_antes, tempos_depois, alternative = "two.sided")
tempos_depois <- c(200, 195, 190, 198, 205, 200, 195, 190)
# Realizando o teste de hipóteses
# O T.TEST comumente usados para comparar as médias de dois grupos e determinar se há uma diferença estatisticamente significativa entre eles.
teste_hipotese <- t.test(tempos_antes, tempos_depois, alternative = "two.sided")
# Imprimindo o resultado do teste de hipóteses
print(teste_hipotese)
# Carregar bibliotecas necessárias
library(sp)
library(spdep)
# Carregar bibliotecas necessárias
library(sp)        # inclui o conjunto de dados meuse
library(spdep)     # biblioteca com funções para análise espacial
library(DescTools) # coletânea de funções estatísticas
library(DescTools) # coletânea de funções estatísticas
# Carregar conjunto de dados meuse
data(meuse)
# Calculando a média espacial da concentração de zinco
media_espacial <- mean(meuse$zinc, na.rm = TRUE)
print(media_espacial)
# Calcular a mediana espacial da concentração de zinco
mediana_espacial <- median(meuse$zinc)
# Calcular a mediana espacial da concentração de zinco
mediana_espacial <- median(meuse$zinc)
print(mediana_espacial)
# Calcular a moda espacial da concentração de zinco
moda_espacial <- Mode(meuse$zinc)
print(moda_espacial)
# Calcular o Índice de Geary:
# - menor que 1: indica autocorrelação positiva, ou seja,
#                valores semelhantes tendem a estar próximos
# - próximo a 1: indica ausência de autocorrelação espacial
# - maior que 1: indica autocorrelação negativa, ou seja,
#                valores semelhantes tendem a estar distantes
#
indice_geary <- geary.test(meuse$zinc, listw)
print(indice_geary)
install.packages(c("geostan", "ggplot2", "gridExtra"))
library(geostan)
library(ggplot2)
library(gridExtra)
data("georgia")
# Utilizamos a função sp_diag() para visualizar a distribuição espacial
# da porcentagem de adultos com diploma universitário
# em cada condado do estado da Geórgia, nos Estados Unidos.
sp_diag(georgia$college, georgia, name  = "College (%)")
# Cria uma matriz de pesos espaciais no estilo binário,
# a partir do objeto georgia.
# Essa matriz será usada para avaliar
# a autocorrelação espacial da variável de porcentagem de diplomas
W <- shape2mat(georgia)
# a inclinação da reta ajustada sugere:
# - positiva: valores próximos tendem a se agrupar
# - 0 (neutra): não há correlação espacial
# - negativa: valores próximos tendem a estar dispersos
moran_plot(georgia$college, W)
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(scales)
library(readr)
# Script R para Análise Descritiva e Regressão Logística
install.packages("readr")
library(readr)
dados <- read_csv("banco.csv",
col_types = cols(
SEXO = readr::col_factor(levels = c("F", "M")),
DTNASC = readr::col_date(format = "%d/%m/%Y"),
IDADE = readr::col_integer(),
HRSDORMIDAS = readr::col_factor(levels = c("menos de 5 horas", "5 horas ou mais")),
HRSTRABALHADAS = readr::col_factor(levels = c("8 horas ou menos", "mais de 8 horas")),
TPTAREFAS = readr::col_factor(levels = c("domésticas", "laborais", "pessoais")),
HUMOR = readr::col_factor(levels = c("Muito bom", "Bom", "Neutro", "Ruim", "Muito ruim")),
SOBRECARGA = readr::col_factor(levels = c("Sim", "Não")),
QUALSONO = readr::col_factor(levels = c("Sim", "Não")),
ENERGIA = readr::col_integer(),
ESTRESSE = readr::col_integer(),
VELDIGITACAO = readr::col_integer(),
TEMPOPAUSA = readr::col_integer(),
TEMPOTELALIGADA = readr::col_integer(),
TEMPOINTERACAO = readr::col_integer(),
TEMPOMOUSE = readr::col_integer()
))
getwd()
# 2. Carregamento dos Dados
dados <- read_csv("/Users/pedrolopeshls/Documents/FIAP/projetos/HumanMate/analytics/banco.csv",
col_types = cols(
SEXO = readr::col_factor(levels = c("F", "M")),
DTNASC = readr::col_date(format = "%d/%m/%Y"),
IDADE = readr::col_integer(),
HRSDORMIDAS = readr::col_factor(levels = c("menos de 5 horas", "5 horas ou mais")),
HRSTRABALHADAS = readr::col_factor(levels = c("8 horas ou menos", "mais de 8 horas")),
TPTAREFAS = readr::col_factor(levels = c("domésticas", "laborais", "pessoais")),
HUMOR = readr::col_factor(levels = c("Muito bom", "Bom", "Neutro", "Ruim", "Muito ruim")),
SOBRECARGA = readr::col_factor(levels = c("Sim", "Não")),
QUALSONO = readr::col_factor(levels = c("Sim", "Não")),
ENERGIA = readr::col_integer(),
ESTRESSE = readr::col_integer(),
VELDIGITACAO = readr::col_integer(),
TEMPOPAUSA = readr::col_integer(),
TEMPOTELALIGADA = readr::col_integer(),
TEMPOINTERACAO = readr::col_integer(),
TEMPOMOUSE = readr::col_integer()
))
quantitativas <- dados %>%
select(IDADE, ENERGIA, ESTRESSE, VELDIGITACAO, TEMPOPAUSA, TEMPOTELALIGADA, TEMPOINTERACAO, TEMPOMOUSE)
cat("\n--- Resumo Estatístico das Variáveis Quantitativas ---\n")
print(summary(quantitativas))
# Adicionar Desvio Padrão
cat("\n--- Desvio Padrão das Variáveis Quantitativas ---\n")
quantitativas %>%
summarise(across(everything(), sd)) %>%
print()
tabela_frequencia <- function(variavel) {
tabela <- dados %>%
count({{ variavel }}) %>%
mutate(Proporcao = n / sum(n),
Proporcao_Perc = paste0(round(Proporcao * 100, 2), "%"))
return(tabela)
}
at("\n--- Tabela de Frequência: SEXO ---\n")
# ==============================================================================
# PARTE 1: ANÁLISE DESCRITIVA
# ==============================================================================
# A. Resumo Estatístico para Variáveis Quantitativas
quantitativas <- dados %>%
select(IDADE, ENERGIA, ESTRESSE, VELDIGITACAO, TEMPOPAUSA, TEMPOTELALIGADA, TEMPOINTERACAO, TEMPOMOUSE)
cat("\n--- Resumo Estatístico das Variáveis Quantitativas ---\n")
print(summary(quantitativas))
# Adicionar Desvio Padrão
cat("\n--- Desvio Padrão das Variáveis Quantitativas ---\n")
quantitativas %>%
summarise(across(everything(), sd)) %>%
print()
# B. Tabela de Frequência e Proporção para Variáveis Categóricas
# Função para gerar tabela de frequência
tabela_frequencia <- function(variavel) {
tabela <- dados %>%
count({{ variavel }}) %>%
mutate(Proporcao = n / sum(n),
Proporcao_Perc = paste0(round(Proporcao * 100, 2), "%"))
return(tabela)
}
cat("\n--- Tabela de Frequência: SEXO ---\n")
print(tabela_frequencia(SEXO))
cat("\n--- Tabela de Frequência: HRSDORMIDAS ---\n")
print(tabela_frequencia(HRSDORMIDAS))
cat("\n--- Tabela de Frequência: HRSTRABALHADAS ---\n")
print(tabela_frequencia(HRSTRABALHADAS))
cat("\n--- Tabela de Frequência: TPTAREFAS ---\n")
print(tabela_frequencia(TPTAREFAS))
cat("\n--- Tabela de Frequência: HUMOR ---\n")
print(tabela_frequencia(HUMOR))
cat("\n--- Tabela de Frequência: SOBRECARGA ---\n")
print(tabela_frequencia(SOBRECARGA))
cat("\n--- Tabela de Frequência: QUALSONO ---\n")
print(tabela_frequencia(QUALSONO))
# C. Visualização Gráfica Descritiva
# Histograma para Variáveis Quantitativas
quantitativas_long <- quantitativas %>%
pivot_longer(cols = everything(), names_to = "Variavel", values_to = "Valor")
grafico_quantitativas <- quantitativas_long %>%
ggplot(aes(x = Valor)) +
geom_histogram(bins = 15, fill = "skyblue", color = "black") +
facet_wrap(~ Variavel, scales = "free") +
labs(title = "Distribuição de Frequência das Variáveis Quantitativas",
x = "Valor",
y = "Frequência") +
theme_minimal() +
theme(strip.text = element_text(face = "bold"))
ggsave("grafico_descritivo_quantitativas.png", plot = grafico_quantitativas, width = 12, height = 8)
# Função para gerar e salvar gráficos de barras
gerar_grafico_barras <- function(variavel, titulo) {
grafico <- dados %>%
ggplot(aes(x = {{ variavel }}, fill = {{ variavel }})) +
geom_bar() +
labs(title = titulo,
x = "",
y = "Contagem") +
theme_minimal() +
theme(legend.position = "none",
axis.text.x = element_text(angle = 45, hjust = 1))
nome_arquivo <- paste0("grafico_descritivo_", deparse(substitute(variavel)), ".png")
ggsave(nome_arquivo, plot = grafico, width = 8, height = 6)
}
# Geração dos gráficos de barras
gerar_grafico_barras(SEXO, "Distribuição de Frequência por Sexo")
gerar_grafico_barras(HRSDORMIDAS, "Distribuição de Horas Dormidas na Última Noite")
gerar_grafico_barras(HRSTRABALHADAS, "Distribuição de Horas Trabalhadas no Dia Anterior")
gerar_grafico_barras(TPTAREFAS, "Distribuição por Tipo de Tarefas")
gerar_grafico_barras(HUMOR, "Distribuição de Humor")
gerar_grafico_barras(SOBRECARGA, "Distribuição de Sobrecarga")
gerar_grafico_barras(QUALSONO, "Distribuição de Qualidade do Sono")
gerar_grafico_barras(ENERGIA, "Distribuição de Nível de Energia")
gerar_grafico_barras(ESTRESSE, "Distribuição de Nível de Estresse")
# ==============================================================================
# PARTE 2: REGRESSÃO LOGÍSTICA (SOBRECARGA ~ ESTRESSE)
# ==============================================================================
cat("\n\n==================================================================")
cat("\nPARTE 2: REGRESSÃO LOGÍSTICA (SOBRECARGA ~ ESTRESSE)")
cat("\n==================================================================\n")
# 1. Preparação dos Dados para Regressão Logística
# A Regressão Logística requer que a variável dependente binária seja convertida para 0 e 1.
# Vamos definir 'Sim' (Sobrecarga) como 1 e 'Não' como 0.
dados_reg <- dados %>%
mutate(SOBRECARGA_BIN = if_else(SOBRECARGA == "Sim", 1, 0))
# 2. Execução da Regressão Logística
# Modelo: SOBRECARGA_BIN em função de ESTRESSE
modelo_logistico <- glm(SOBRECARGA_BIN ~ ESTRESSE,
data = dados_reg,
family = binomial(link = "logit"))
cat("\n--- Resultados da Regressão Logística (SOBRECARGA ~ ESTRESSE) ---\n")
print(summary(modelo_logistico))
# 3. Interpretação dos Coeficientes (Odds Ratio)
cat("\n--- Odds Ratio (Razão de Chances) ---\n")
print(exp(coef(modelo_logistico)))
# 4. Geração do Gráfico de Probabilidade
# Criar uma nova coluna com as probabilidades previstas pelo modelo
dados_reg <- dados_reg %>%
mutate(PROBABILIDADE_SOBRECARGA = predict(modelo_logistico, type = "response"))
# Gráfico de dispersão com a curva de probabilidade logística
grafico_regressao <- dados_reg %>%
ggplot(aes(x = ESTRESSE, y = PROBABILIDADE_SOBRECARGA)) +
# Adiciona os pontos de dados (jitter para melhor visualização)
geom_point(aes(y = SOBRECARGA_BIN),
position = position_jitter(height = 0.02, width = 0.1),
alpha = 0.5,
color = "gray50") +
# Adiciona a curva de probabilidade prevista
geom_smooth(method = "glm",
method.args = list(family = "binomial"),
se = TRUE,
color = "blue") +
labs(title = "Probabilidade de Sobrecarga em Função do Nível de Estresse",
x = "Nível de Estresse (1 a 5)",
y = "Probabilidade de Sobrecarga (Sim)") +
scale_y_continuous(labels = scales::percent) +
theme_minimal()
# Salvar o gráfico
ggsave("grafico_regressao_logistica_sobrecarga.png", plot = grafico_regressao, width = 10, height = 6)
# Salvar o gráfico
ggsave("grafico_regressao_logistica_sobrecarga.png", plot = grafico_regressao, width = 10, height = 6)
# Salvar o gráfico
ggsave("/Users/pedrolopeshls/Documents/FIAP/projetos/HumanMate/analytics/grafico_regressao_logistica_sobrecarga.png", plot = grafico_regressao, width = 10, height = 6)
# 2. Carregamento dos Dados
dados <- read_csv("/Users/pedrolopeshls/Documents/FIAP/projetos/HumanMate/analytics/banco.csv",
col_types = cols(
SEXO = readr::col_factor(levels = c("F", "M")),
DTNASC = readr::col_date(format = "%d/%m/%Y"),
IDADE = readr::col_integer(),
HRSDORMIDAS = readr::col_factor(levels = c("menos de 5 horas", "5 horas ou mais")),
HRSTRABALHADAS = readr::col_factor(levels = c("8 horas ou menos", "mais de 8 horas")),
TPTAREFAS = readr::col_factor(levels = c("domésticas", "laborais", "pessoais")),
HUMOR = readr::col_factor(levels = c("Muito bom", "Bom", "Neutro", "Ruim", "Muito ruim")),
SOBRECARGA = readr::col_factor(levels = c("Sim", "Não")),
QUALSONO = readr::col_factor(levels = c("Sim", "Não")),
ENERGIA = readr::col_integer(),
ESTRESSE = readr::col_integer(),
VELDIGITACAO = readr::col_integer(),
TEMPOPAUSA = readr::col_integer(),
TEMPOTELALIGADA = readr::col_integer(),
TEMPOINTERACAO = readr::col_integer(),
TEMPOMOUSE = readr::col_integer()
))
# ==============================================================================
# PARTE 1: ANÁLISE DESCRITIVA
# ==============================================================================
# A. Resumo Estatístico para Variáveis Quantitativas
quantitativas <- dados %>%
select(IDADE, ENERGIA, ESTRESSE, VELDIGITACAO, TEMPOPAUSA, TEMPOTELALIGADA, TEMPOINTERACAO, TEMPOMOUSE)
cat("\n--- Resumo Estatístico das Variáveis Quantitativas ---\n")
print(summary(quantitativas))
# Adicionar Desvio Padrão
cat("\n--- Desvio Padrão das Variáveis Quantitativas ---\n")
quantitativas %>%
summarise(across(everything(), sd)) %>%
print()
# B. Tabela de Frequência e Proporção para Variáveis Categóricas
# Função para gerar tabela de frequência
tabela_frequencia <- function(variavel) {
tabela <- dados %>%
count({{ variavel }}) %>%
mutate(Proporcao = n / sum(n),
Proporcao_Perc = paste0(round(Proporcao * 100, 2), "%"))
return(tabela)
}
cat("\n--- Tabela de Frequência: SEXO ---\n")
print(tabela_frequencia(SEXO))
cat("\n--- Tabela de Frequência: HRSDORMIDAS ---\n")
print(tabela_frequencia(HRSDORMIDAS))
cat("\n--- Tabela de Frequência: HRSTRABALHADAS ---\n")
print(tabela_frequencia(HRSTRABALHADAS))
cat("\n--- Tabela de Frequência: TPTAREFAS ---\n")
print(tabela_frequencia(TPTAREFAS))
cat("\n--- Tabela de Frequência: HUMOR ---\n")
print(tabela_frequencia(HUMOR))
cat("\n--- Tabela de Frequência: SOBRECARGA ---\n")
print(tabela_frequencia(SOBRECARGA))
cat("\n--- Tabela de Frequência: QUALSONO ---\n")
print(tabela_frequencia(QUALSONO))
# C. Visualização Gráfica Descritiva
# Histograma para Variáveis Quantitativas
quantitativas_long <- quantitativas %>%
pivot_longer(cols = everything(), names_to = "Variavel", values_to = "Valor")
grafico_quantitativas <- quantitativas_long %>%
ggplot(aes(x = Valor)) +
geom_histogram(bins = 15, fill = "skyblue", color = "black") +
facet_wrap(~ Variavel, scales = "free") +
labs(title = "Distribuição de Frequência das Variáveis Quantitativas",
x = "Valor",
y = "Frequência") +
theme_minimal() +
theme(strip.text = element_text(face = "bold"))
ggsave("grafico_descritivo_quantitativas.png", plot = grafico_quantitativas, width = 12, height = 8)
# Função para gerar e salvar gráficos de barras
gerar_grafico_barras <- function(variavel, titulo) {
grafico <- dados %>%
ggplot(aes(x = {{ variavel }}, fill = {{ variavel }})) +
geom_bar() +
labs(title = titulo,
x = "",
y = "Contagem") +
theme_minimal() +
theme(legend.position = "none",
axis.text.x = element_text(angle = 45, hjust = 1))
nome_arquivo <- paste0("grafico_descritivo_", deparse(substitute(variavel)), ".png")
ggsave(nome_arquivo, plot = grafico, width = 8, height = 6)
}
# Geração dos gráficos de barras
gerar_grafico_barras(SEXO, "Distribuição de Frequência por Sexo")
gerar_grafico_barras(HRSDORMIDAS, "Distribuição de Horas Dormidas na Última Noite")
gerar_grafico_barras(HRSTRABALHADAS, "Distribuição de Horas Trabalhadas no Dia Anterior")
gerar_grafico_barras(TPTAREFAS, "Distribuição por Tipo de Tarefas")
gerar_grafico_barras(HUMOR, "Distribuição de Humor")
gerar_grafico_barras(SOBRECARGA, "Distribuição de Sobrecarga")
gerar_grafico_barras(QUALSONO, "Distribuição de Qualidade do Sono")
gerar_grafico_barras(ENERGIA, "Distribuição de Nível de Energia")
gerar_grafico_barras(ESTRESSE, "Distribuição de Nível de Estresse")
# ==============================================================================
# PARTE 2: REGRESSÃO LOGÍSTICA (SOBRECARGA ~ ESTRESSE)
# ==============================================================================
cat("\n\n==================================================================")
cat("\nPARTE 2: REGRESSÃO LOGÍSTICA (SOBRECARGA ~ ESTRESSE)")
cat("\n==================================================================\n")
# 1. Preparação dos Dados para Regressão Logística
# A Regressão Logística requer que a variável dependente binária seja convertida para 0 e 1.
# Vamos definir 'Sim' (Sobrecarga) como 1 e 'Não' como 0.
dados_reg <- dados %>%
mutate(SOBRECARGA_BIN = if_else(SOBRECARGA == "Sim", 1, 0))
# 2. Execução da Regressão Logística
# Modelo: SOBRECARGA_BIN em função de ESTRESSE
modelo_logistico <- glm(SOBRECARGA_BIN ~ ESTRESSE,
data = dados_reg,
family = binomial(link = "logit"))
cat("\n--- Resultados da Regressão Logística (SOBRECARGA ~ ESTRESSE) ---\n")
print(summary(modelo_logistico))
# 3. Interpretação dos Coeficientes (Odds Ratio)
cat("\n--- Odds Ratio (Razão de Chances) ---\n")
print(exp(coef(modelo_logistico)))
# 4. Geração do Gráfico de Probabilidade
# Criar uma nova coluna com as probabilidades previstas pelo modelo
dados_reg <- dados_reg %>%
mutate(PROBABILIDADE_SOBRECARGA = predict(modelo_logistico, type = "response"))
# Gráfico de dispersão com a curva de probabilidade logística
grafico_regressao <- dados_reg %>%
ggplot(aes(x = ESTRESSE, y = PROBABILIDADE_SOBRECARGA)) +
# Adiciona os pontos de dados (jitter para melhor visualização)
geom_point(aes(y = SOBRECARGA_BIN),
position = position_jitter(height = 0.02, width = 0.1),
alpha = 0.5,
color = "gray50") +
# Adiciona a curva de probabilidade prevista
geom_smooth(method = "glm",
method.args = list(family = "binomial"),
se = TRUE,
color = "blue") +
labs(title = "Probabilidade de Sobrecarga em Função do Nível de Estresse",
x = "Nível de Estresse (1 a 5)",
y = "Probabilidade de Sobrecarga (Sim)") +
scale_y_continuous(labels = scales::percent) +
theme_minimal()
# Salvar o gráfico
ggsave("/Users/pedrolopeshls/Documents/FIAP/projetos/HumanMate/analytics/grafico_regressao_logistica_sobrecarga.png", plot = grafico_regressao, width = 10, height = 6)
# Carregar as bibliotecas necessárias
library(readr)
library(rpart)
library(rpart.plot)
install.packages("rpart.plot")
library(rpart.plot)
# --- 1. CARREGAR OS DADOS (DE FORMA MAIS ROBUSTA) ---
# <<< ALTERAÇÃO AQUI >>>
# Especificamos o tipo de cada coluna para evitar que o R interprete errado.
# t = timestamp (character), d = double (número com decimal), i = integer (inteiro), f = factor (categórico)
tipos_colunas <- cols(
timestamp = col_character(),
n = col_integer(),
p = col_integer(),
k = col_integer(),
ph = col_double(),
umidade = col_double(),
acao_bomba = col_factor()
)
# Ler o arquivo CSV usando os tipos de coluna que definimos.
# Lembre-se de ajustar o caminho se necessário.
dados_irrigacao <- read_csv("sensores-Trab1_fase2_cap1/historico_irrigacao.csv", col_types = tipos_colunas)
setwd("~/Documents/FIAP/projetos")
setwd("~/Documents/FIAP/projetos/farm-tech/fase_2/sensores-Trab1_fase2_cap1")
# --- 1. CARREGAR OS DADOS (DE FORMA MAIS ROBUSTA) ---
# <<< ALTERAÇÃO AQUI >>>
# Especificamos o tipo de cada coluna para evitar que o R interprete errado.
# t = timestamp (character), d = double (número com decimal), i = integer (inteiro), f = factor (categórico)
tipos_colunas <- cols(
timestamp = col_character(),
n = col_integer(),
p = col_integer(),
k = col_integer(),
ph = col_double(),
umidade = col_double(),
acao_bomba = col_factor()
)
# Ler o arquivo CSV usando os tipos de coluna que definimos.
# Lembre-se de ajustar o caminho se necessário.
dados_irrigacao <- read_csv("sensores-Trab1_fase2_cap1/historico_irrigacao.csv", col_types = tipos_colunas)
# --- 1. CARREGAR OS DADOS (DE FORMA MAIS ROBUSTA) ---
# <<< ALTERAÇÃO AQUI >>>
# Especificamos o tipo de cada coluna para evitar que o R interprete errado.
# t = timestamp (character), d = double (número com decimal), i = integer (inteiro), f = factor (categórico)
tipos_colunas <- cols(
timestamp = col_character(),
n = col_integer(),
p = col_integer(),
k = col_integer(),
ph = col_double(),
umidade = col_double(),
acao_bomba = col_factor()
)
# Ler o arquivo CSV usando os tipos de coluna que definimos.
# Lembre-se de ajustar o caminho se necessário.
dados_irrigacao <- read_csv("historico_irrigacao.csv", col_types = tipos_colunas)
# --- O RESTO DO CÓDIGO CONTINUA O MESMO ---
# Visualizar as primeiras linhas para confirmar que os tipos estão corretos agora
print(head(dados_irrigacao))
print(summary(dados_irrigacao))
# Construir o modelo de árvore de decisão
modelo_arvore <- rpart(
acao_bomba ~ umidade + ph + n + p + k,
data = dados_irrigacao,
method = "class"
)
# Plotar a nova árvore de decisão
rpart.plot(
modelo_arvore,
main = "Árvore de Decisão para Irrigação da FarmTech (v2)",
box.palette = "Blues",
shadow.col = "gray",
nn = TRUE
)
# Imprimir um resumo das regras
printcp(modelo_arvore)
